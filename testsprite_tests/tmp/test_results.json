[
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "d071a0ba-7612-4002-bf57-85778d57fb0e",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC001-authenticate using username or email plus password",
    "description": "Test the /api/login endpoint to verify successful authentication with valid username/email and password, including optional remember_me functionality. Validate error responses for missing credentials and invalid login attempts.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nAUTH_USERNAME = \"uniquebishwo@gmail.com\"\nAUTH_PASSWORD = \"c9PU7XAsAADYk_A\"\nTIMEOUT = 30\n\ndef test_authenticate_using_username_or_email_plus_password():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    login_url = f\"{BASE_URL}/api/login\"\n\n    # Successful login with username_email and password (without remember_me)\n    payload_valid = {\n        \"username_email\": AUTH_USERNAME,\n        \"password\": AUTH_PASSWORD\n    }\n    try:\n        response = requests.post(login_url, json=payload_valid, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        json_resp = response.json()\n        assert isinstance(json_resp, dict) and len(json_resp) > 0, \"Response JSON is empty or invalid\"\n    except requests.RequestException as e:\n        assert False, f\"RequestException during valid login test: {e}\"\n\n    # Successful login with remember_me True\n    payload_remember_me = {\n        \"username_email\": AUTH_USERNAME,\n        \"password\": AUTH_PASSWORD,\n        \"remember_me\": True\n    }\n    try:\n        response = requests.post(login_url, json=payload_remember_me, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK with remember_me, got {response.status_code}\"\n        json_resp = response.json()\n        assert isinstance(json_resp, dict) and len(json_resp) > 0, \"Response JSON is empty or invalid with remember_me\"\n    except requests.RequestException as e:\n        assert False, f\"RequestException during login with remember_me test: {e}\"\n\n    # Error case: missing username_email\n    payload_missing_username = {\n        \"password\": AUTH_PASSWORD\n    }\n    try:\n        response = requests.post(login_url, json=payload_missing_username, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 Bad Request for missing username_email, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"RequestException during missing username_email test: {e}\"\n\n    # Error case: missing password\n    payload_missing_password = {\n        \"username_email\": AUTH_USERNAME\n    }\n    try:\n        response = requests.post(login_url, json=payload_missing_password, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 400, f\"Expected 400 Bad Request for missing password, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"RequestException during missing password test: {e}\"\n\n    # Error case: invalid username_email and password\n    payload_invalid_credentials = {\n        \"username_email\": \"invalid_user@example.com\",\n        \"password\": \"wrongpassword\"\n    }\n    try:\n        response = requests.post(login_url, json=payload_invalid_credentials, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 401, f\"Expected 401 Unauthorized for invalid login, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"RequestException during invalid login test: {e}\"\n\ntest_authenticate_using_username_or_email_plus_password()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.814Z",
    "modified": "2025-11-17T18:02:30.977Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "3fab8f73-0f0f-426d-a778-40892221b697",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC002-destroy active session and auth token on logout",
    "description": "Test the /api/logout endpoint to ensure it properly destroys the active user session and authentication token. Verify correct response for authenticated users and error response for unauthenticated access.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nAUTH_CREDENTIALS = {\n    \"username_email\": \"uniquebishwo@gmail.com\",\n    \"password\": \"c9PU7XAsAADYk_A\"\n}\nTIMEOUT = 30\n\n\ndef test_destroy_active_session_and_auth_token_on_logout():\n    session = requests.Session()\n    login_url = f\"{BASE_URL}/api/login\"\n    logout_url = f\"{BASE_URL}/api/logout\"\n\n    # Step 1: Login to get authenticated session and token\n    try:\n        login_resp = session.post(\n            login_url,\n            json=AUTH_CREDENTIALS,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        # Assuming token/session cookie set here for authenticated session\n        # Validate a token or session cookie presence\n        # This API uses session & cookie authentication so checking cookies\n        assert session.cookies, \"No cookies set after login\"\n\n        # Step 2: Perform authenticated logout\n        logout_resp = session.get(logout_url, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200, f\"Logout failed with status {logout_resp.status_code}\"\n        # Response text or json can confirm logout success\n        # We expect JSON or text confirming logout; accept any 200 as success here\n        # Check also that cookies/session cleared or token invalidated\n        # Session cookie likely removed or expired after logout\n        # We can try to access logout again, expecting unauthorized\n        # Or check that cookies cleared or another request fails auth\n\n        # Step 3: Verify access with same session now unauthorized\n        logout_resp_2 = session.get(logout_url, timeout=TIMEOUT)\n        assert logout_resp_2.status_code == 401, (\n            f\"Expected 401 Unauthorized after logout but got {logout_resp_2.status_code}\"\n        )\n    finally:\n        session.close()\n\n    # Step 4: Test logout endpoint without authentication\n    unauth_session = requests.Session()\n    try:\n        unauth_logout_resp = unauth_session.get(logout_url, timeout=TIMEOUT)\n        assert unauth_logout_resp.status_code == 401, (\n            f\"Expected 401 Unauthorized for unauthenticated logout but got {unauth_logout_resp.status_code}\"\n        )\n    finally:\n        unauth_session.close()\n\n\ntest_destroy_active_session_and_auth_token_on_logout()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 41, in test_destroy_active_session_and_auth_token_on_logout\nAssertionError: Expected 401 Unauthorized after logout but got 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.830Z",
    "modified": "2025-11-17T18:01:51.650Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "e0940e51-f7a9-4c29-bcb1-6d152b1815ff",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC003-check username availability for registration",
    "description": "Test the /api/check-username endpoint to confirm it correctly checks username availability and provides suggestions. Validate handling of invalid input and proper success response.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nAUTH_USERNAME = \"uniquebishwo@gmail.com\"\nAUTH_PASSWORD = \"c9PU7XAsAADYk_A\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_check_username_availability():\n    auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n\n    # Valid username availability check\n    payload_valid = {\"username\": \"testuser123\"}\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/check-username\",\n            json=payload_valid,\n            headers=HEADERS,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        data = response.json()\n        assert \"available\" in data or \"suggestions\" in data, \"Response missing expected keys\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Invalid input: missing username field\n    payload_invalid_empty = {}\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/check-username\",\n            json=payload_invalid_empty,\n            headers=HEADERS,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 400, f\"Expected 400 Bad Request for missing username, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Invalid input: username is None\n    payload_invalid_none = {\"username\": None}\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/check-username\",\n            json=payload_invalid_none,\n            headers=HEADERS,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 400, f\"Expected 400 Bad Request for null username, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Invalid input: username as an integer\n    payload_invalid_type = {\"username\": 123456}\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/check-username\",\n            json=payload_invalid_type,\n            headers=HEADERS,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        # Assuming server rejects invalid types with 400\n        assert response.status_code == 400, f\"Expected 400 Bad Request for non-string username, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_check_username_availability()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.853Z",
    "modified": "2025-11-17T18:01:28.700Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "dcc9b4a7-e616-4567-aa96-2dd10fbd9d10",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC004-trigger password reset email dispatch",
    "description": "Test the /api/forgot-password endpoint to verify that a password reset email is queued when a valid registered email is provided. Confirm appropriate error response when the account is not found.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nAUTH = HTTPBasicAuth(\"uniquebishwo@gmail.com\", \"c9PU7XAsAADYk_A\")\nTIMEOUT = 30\n\ndef test_trigger_password_reset_email_dispatch():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Test valid registered email triggers reset email queued (200)\n    valid_email = \"uniquebishwo@gmail.com\"\n    valid_payload = {\"email\": valid_email}\n    try:\n        response_valid = requests.post(\n            f\"{BASE_URL}/api/forgot-password\",\n            json=valid_payload,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_valid.status_code == 200, f\"Expected 200 for valid email, got {response_valid.status_code}\"\n        # Optional: check response content if needed\n    except requests.RequestException as e:\n        assert False, f\"Request failed for valid email: {e}\"\n\n    # Test non-registered email returns 404 Account not found\n    invalid_email = \"nonexistent_email_for_test_999@example.com\"\n    invalid_payload = {\"email\": invalid_email}\n    try:\n        response_invalid = requests.post(\n            f\"{BASE_URL}/api/forgot-password\",\n            json=invalid_payload,\n            headers=headers,\n            auth=AUTH,\n            timeout=TIMEOUT\n        )\n        assert response_invalid.status_code == 404, f\"Expected 404 for unknown email, got {response_invalid.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed for invalid email: {e}\"\n\ntest_trigger_password_reset_email_dispatch()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.865Z",
    "modified": "2025-11-17T18:01:40.245Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "706f8dca-e85a-4ed0-9790-776db7eddbfb",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC005-register a new user with valid data",
    "description": "Test the /api/register endpoint to ensure new users can be registered with valid username, email, password, and optional profile details. Validate error handling for validation failures and duplicate username or email.",
    "code": "import requests\nimport string\nimport random\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nREGISTER_ENDPOINT = \"/api/register\"\nDELETE_ENDPOINT_TEMPLATE = \"/api/users/{user_id}\"\n\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef generate_random_username_email():\n    suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))\n    username = f\"testuser_{suffix}\"\n    email = f\"{username}@example.com\"\n    return username, email\n\ndef test_register_new_user_with_valid_data():\n    username, email = generate_random_username_email()\n    payload = {\n        \"username\": username,\n        \"email\": email,\n        \"password\": \"ValidPass123!\",\n        \"first_name\": \"Test\",\n        \"last_name\": \"User\",\n        \"terms_agree\": True\n    }\n    user_id = None\n\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n            json=payload,\n            headers=HEADERS,\n            timeout=30\n        )\n        # Validate success or expected error if duplicate\n        if resp.status_code == 200:\n            data = resp.json()\n            assert 'id' in data, \"Response JSON must include 'id'\"\n            user_id = data['id']\n        elif resp.status_code == 400:\n            # Validation failure - should not happen with valid data\n            raise AssertionError(f\"Validation failure when using valid data: {resp.text}\")\n        elif resp.status_code == 409:\n            # Duplicate user detected\n            raise AssertionError(\"User with same username or email already exists.\")\n        else:\n            resp.raise_for_status()\n\n        # Additionally, test error handling for duplicate username/email, by sending again\n        resp_dup = requests.post(\n            f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n            json=payload,\n            headers=HEADERS,\n            timeout=30\n        )\n        assert resp_dup.status_code == 409, \"Duplicate registration must return 409 Conflict\"\n\n        # Test validation failure by missing required 'password'\n        invalid_payload = payload.copy()\n        invalid_payload.pop(\"password\")\n        resp_invalid = requests.post(\n            f\"{BASE_URL}{REGISTER_ENDPOINT}\",\n            json=invalid_payload,\n            headers=HEADERS,\n            timeout=30\n        )\n        assert resp_invalid.status_code == 400, \"Missing password should return 400 validation error\"\n\n    finally:\n        # Cleanup: delete created user if possible\n        if user_id is not None:\n            try:\n                delete_resp = requests.delete(\n                    f\"{BASE_URL}{DELETE_ENDPOINT_TEMPLATE.format(user_id=user_id)}\",\n                    headers=HEADERS,\n                    timeout=30\n                )\n                # It's okay if delete_resp is 200 or 204; ignore others but do not raise here\n            except Exception:\n                pass\n\ntest_register_new_user_with_valid_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 86, in <module>\n  File \"<string>\", line 42, in test_register_new_user_with_valid_data\nAssertionError: Response JSON must include 'id'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.869Z",
    "modified": "2025-11-17T18:02:58.443Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "b0fa2ff8-49da-4c20-b079-47a348c17df6",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC006-retrieve profile for authenticated user",
    "description": "Test the /profile GET endpoint to confirm it returns the profile information for the current authenticated session user. Verify unauthorized access is properly rejected.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nAUTH_USERNAME = \"uniquebishwo@gmail.com\"\nAUTH_PASSWORD = \"c9PU7XAsAADYk_A\"\nTIMEOUT = 30\n\ndef test_retrieve_profile_authenticated_user():\n    headers = {\"Accept\": \"application/json\"}\n\n    # Test unauthorized access - no auth headers\n    unauthorized_response = requests.get(f\"{BASE_URL}/profile\", headers=headers, timeout=TIMEOUT)\n    assert unauthorized_response.status_code == 401, f\"Expected 401 Unauthorized, got {unauthorized_response.status_code}\"\n\n    # Test authorized access - basic token auth (HTTP Basic Auth)\n    try:\n        auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n        auth_response = requests.get(f\"{BASE_URL}/profile\", headers=headers, auth=auth, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert auth_response.status_code == 200, f\"Expected 200 OK, got {auth_response.status_code}\"\n\n    try:\n        profile_data = auth_response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Basic validation of profile structure\n    assert isinstance(profile_data, dict), \"Profile response is not a JSON object\"\n    # The profile must include at least one identifying field like 'email' or 'username'\n    assert any(key in profile_data for key in (\"email\", \"username\", \"first_name\", \"last_name\")), \\\n        \"Profile JSON does not contain expected user fields\"\n\ntest_retrieve_profile_authenticated_user()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.873Z",
    "modified": "2025-11-17T18:01:35.772Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "2d9e9ea1-32a4-400b-a3f8-96616c20ac1b",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC007-update profile information and preferences",
    "description": "Test the /profile PUT endpoint to verify that authenticated users can update their profile information including first name, last name, company, and phone. Validate input validation and unauthorized access handling.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nAUTH_CREDENTIALS = (\"uniquebishwo@gmail.com\", \"c9PU7XAsAADYk_A\")\nTIMEOUT = 30\n\ndef test_TC007_update_profile_information_and_preferences():\n    session = requests.Session()\n\n    # Authenticate user to obtain session/cookies\n    login_url = f\"{BASE_URL}/api/login\"\n    login_payload = {\n        \"username_email\": AUTH_CREDENTIALS[0],\n        \"password\": AUTH_CREDENTIALS[1]\n    }\n    login_headers = {\"Content-Type\": \"application/json\"}\n    login_resp = session.post(login_url, json=login_payload, headers=login_headers, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n\n    try:\n        # Valid update profile request\n        update_url = f\"{BASE_URL}/profile\"\n        valid_payload = {\n            \"first_name\": \"TestFirst\",\n            \"last_name\": \"TestLast\",\n            \"company\": \"TestCompany\",\n            \"phone\": \"+1234567890\"\n        }\n        headers = {\"Content-Type\": \"application/json\"}\n\n        put_resp = session.put(update_url, json=valid_payload, headers=headers, timeout=TIMEOUT)\n        assert put_resp.status_code == 200, f\"Expected 200 on valid update, got {put_resp.status_code}\"\n\n        # Validate response content for success if any\n        # (Assuming response is JSON and might echo updated profile or confirmation)\n        try:\n            json_data = put_resp.json()\n            # Could validate that json_data contains updated fields if spec provided\n            for key in valid_payload:\n                if key in json_data:\n                    assert json_data[key] == valid_payload[key], f\"Mismatch in {key} after update\"\n        except Exception:\n            # If no JSON or no body, skip\n\n            pass\n\n        # Input validation - invalid payload (e.g., phone number as integer)\n        invalid_payload = {\n            \"first_name\": \"Test\",\n            \"last_name\": \"User\",\n            \"company\": \"TestCo\",\n            \"phone\": 12345  # invalid type, phone should be string\n        }\n        resp_invalid = session.put(update_url, json=invalid_payload, headers=headers, timeout=TIMEOUT)\n        assert resp_invalid.status_code == 400, f\"Expected 400 on invalid input, got {resp_invalid.status_code}\"\n\n        # Unauthorized access: call without auth\n    finally:\n        # Logout after tests\n        logout_url = f\"{BASE_URL}/api/logout\"\n        session.get(logout_url, timeout=TIMEOUT)\n\n    # Unauthorized test without session or auth headers\n    unauth_session = requests.Session()\n    resp_unauth = unauth_session.put(update_url, json=valid_payload, headers={\"Content-Type\": \"application/json\"}, timeout=TIMEOUT)\n    assert resp_unauth.status_code == 401, f\"Expected 401 unauthorized, got {resp_unauth.status_code}\"\n\ntest_TC007_update_profile_information_and_preferences()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.877Z",
    "modified": "2025-11-17T18:01:51.648Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "5ba146b0-fe7f-4828-93dd-fe3b9e638cbc",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC008-render admin dashboard overview for authorized users",
    "description": "Test the /admin GET endpoint to ensure the admin dashboard overview is rendered correctly for authenticated admin users. Verify redirection for unauthenticated users and forbidden access for non-admins.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nADMIN_ENDPOINT = \"/admin\"\nLOGIN_ENDPOINT = \"/api/login\"\n\nUSERNAME = \"uniquebishwo@gmail.com\"\nPASSWORD = \"c9PU7XAsAADYk_A\"\n\nTIMEOUT = 30\n\ndef test_TC008_render_admin_dashboard_overview_for_authorized_users():\n    session = requests.Session()\n\n    try:\n        # Authenticate as admin user to get session cookies/auth headers\n        login_payload = {\n            \"username_email\": USERNAME,\n            \"password\": PASSWORD\n        }\n        login_resp = session.post(\n            f\"{BASE_URL}{LOGIN_ENDPOINT}\",\n            json=login_payload,\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n\n        # 1. Authorized admin user access\n        admin_resp = session.get(f\"{BASE_URL}{ADMIN_ENDPOINT}\", timeout=TIMEOUT)\n        assert admin_resp.status_code == 200, f\"Admin dashboard not rendered for authorized admin: {admin_resp.status_code}, {admin_resp.text}\"\n        content_type = admin_resp.headers.get(\"Content-Type\", \"\")\n        assert \"text/html\" in content_type.lower() or \"application/json\" in content_type.lower(), f\"Unexpected content type for admin dashboard: {content_type}\"\n        assert len(admin_resp.text) > 0, \"Admin dashboard response body is empty\"\n\n        # 2. Unauthenticated user access => should redirect (302) to login\n        # Use a separate session without authentication\n        unauth_session = requests.Session()\n        unauth_resp = unauth_session.get(f\"{BASE_URL}{ADMIN_ENDPOINT}\", allow_redirects=False, timeout=TIMEOUT)\n        assert unauth_resp.status_code == 302, f\"Expected redirect (302) for unauthenticated user, got: {unauth_resp.status_code}\"\n        location_header = unauth_resp.headers.get(\"Location\", \"\")\n        assert location_header, \"Redirect response missing Location header\"\n        # Assuming redirect location contains 'login' or similar string\n        assert any(s in location_header.lower() for s in [\"login\", \"/api/login\"]), f\"Redirect location does not point to login: {location_header}\"\n\n        # 3. Authenticated non-admin user access => should be forbidden (403)\n        # To simulate a non-admin user, register a new user or use a known non-admin user.\n        # Here we register a temporary user, then login as that user and test access.\n        # Since the test instructions do not provide a non-admin user credential, we create non-admin user temporarily.\n\n        # Register a new non-admin user\n        register_endpoint = \"/api/register\"\n        import random, string\n        random_str = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))\n        new_username = f\"testuser_{random_str}\"\n        new_email = f\"{new_username}@example.com\"\n        new_password = \"TestPass123!\"\n\n        register_payload = {\n            \"username\": new_username,\n            \"email\": new_email,\n            \"password\": new_password,\n            \"first_name\": \"Test\",\n            \"last_name\": \"User\",\n            \"terms_agree\": True\n        }\n\n        reg_resp = session.post(f\"{BASE_URL}{register_endpoint}\", json=register_payload, timeout=TIMEOUT)\n        assert reg_resp.status_code == 200, f\"Failed to register non-admin user: {reg_resp.status_code} {reg_resp.text}\"\n        user_id = None\n        try:\n            # Login as the non-admin user\n            non_admin_session = requests.Session()\n            login_payload_non_admin = {\n                \"username_email\": new_username,\n                \"password\": new_password\n            }\n            login_non_admin_resp = non_admin_session.post(f\"{BASE_URL}{LOGIN_ENDPOINT}\", json=login_payload_non_admin, timeout=TIMEOUT)\n            assert login_non_admin_resp.status_code == 200, f\"Login failed for non-admin user: {login_non_admin_resp.text}\"\n\n            # Attempt to access admin dashboard as non-admin user\n            non_admin_admin_resp = non_admin_session.get(f\"{BASE_URL}{ADMIN_ENDPOINT}\", timeout=TIMEOUT)\n            assert non_admin_admin_resp.status_code == 403, f\"Expected 403 Forbidden for non-admin user, got {non_admin_admin_resp.status_code}\"\n        finally:\n            # No endpoint documented for user deletion; skip cleanup to avoid side effects. \n            # Usually, user deletion or disabling endpoints would be needed, but not provided.\n            pass\n\n    finally:\n        # Logout admin user session if applicable\n        logout_endpoint = \"/api/logout\"\n        try:\n            session.get(f\"{BASE_URL}{logout_endpoint}\", timeout=TIMEOUT)\n        except Exception:\n            pass\n\n\ntest_TC008_render_admin_dashboard_overview_for_authorized_users()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 40, in test_TC008_render_admin_dashboard_overview_for_authorized_users\nAssertionError: Expected redirect (302) for unauthenticated user, got: 200\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.882Z",
    "modified": "2025-11-17T18:02:39.932Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "95185782-5e6b-4761-8a77-fb503dd40bb3",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC009-return requested admin settings section ui",
    "description": "Test the /admin/settings/{section} GET endpoint to confirm it returns the correct settings section UI for valid sections (general, users, security, email, advanced). Validate 404 response for invalid sections.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nUSERNAME = \"uniquebishwo@gmail.com\"\nPASSWORD = \"c9PU7XAsAADYk_A\"\nTIMEOUT = 30\n\ndef test_return_requested_admin_settings_section_ui():\n    auth = HTTPBasicAuth(USERNAME, PASSWORD)\n    valid_sections = [\"general\", \"users\", \"security\", \"email\", \"advanced\"]\n    headers = {\n        \"Accept\": \"text/html\"\n    }\n\n    # Test valid sections - expect 200 and some content\n    for section in valid_sections:\n        try:\n            url = f\"{BASE_URL}/admin/settings/{section}\"\n            response = requests.get(url, auth=auth, headers=headers, timeout=TIMEOUT)\n            assert response.status_code == 200, f\"Expected 200 for section '{section}', got {response.status_code}\"\n            # Validate response looks like HTML containing the section name (basic check)\n            content = response.text.lower()\n            assert section in content or len(content) > 0, f\"Response content for section '{section}' seems invalid\"\n        except requests.exceptions.RequestException as e:\n            assert False, f\"Request failed for section '{section}': {e}\"\n\n    # Test invalid section - expect 404\n    invalid_section = \"invalidsection\"\n    try:\n        url = f\"{BASE_URL}/admin/settings/{invalid_section}\"\n        response = requests.get(url, auth=auth, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 404, f\"Expected 404 for invalid section, got {response.status_code}\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed for invalid section test: {e}\"\n\ntest_return_requested_admin_settings_section_ui()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.895Z",
    "modified": "2025-11-17T18:02:18.746Z"
  },
  {
    "projectId": "274b56cb-b8d6-4463-af7a-0860bb9edf25",
    "testId": "26a48994-2480-4fc8-ab13-266919d66d0e",
    "userId": "44f8f408-3011-70ce-b217-216918e007b7",
    "title": "TC010-list and manage registered users in admin panel",
    "description": "Test the /admin/users GET endpoint to verify it returns the user management table for authorized admin users and returns forbidden error for unauthorized access.",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:80/Bishwo_Calculator\"\nADMIN_USERS_ENDPOINT = \"/admin/users\"\nTIMEOUT = 30\n\nauth_credentials = HTTPBasicAuth(\"uniquebishwo@gmail.com\", \"c9PU7XAsAADYk_A\")\n\ndef test_admin_users_list_and_access_control():\n    # 1. Test authorized access with valid basic token credentials\n    try:\n        response = requests.get(\n            BASE_URL + ADMIN_USERS_ENDPOINT,\n            auth=auth_credentials,\n            timeout=TIMEOUT\n        )\n    except requests.RequestException as e:\n        assert False, f\"Request for authorized admin user failed: {e}\"\n    else:\n        assert response.status_code == 200, f\"Expected 200 OK for authorized admin, got {response.status_code}\"\n        # The user management table should be present in HTML or JSON - minimal check:\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        assert \"html\" in content_type.lower() or \"json\" in content_type.lower(), \\\n            f\"Unexpected content type for admin users list: {content_type}\"\n        # Also basic content check for some keywords indicating user management\n        content_lower = response.text.lower()\n        assert (\"user\" in content_lower and \"manage\" in content_lower) or \"table\" in content_lower, \\\n            \"Response content does not seem to contain user management table\"\n\n    # 2. Test unauthorized access (no credentials)\n    try:\n        response_unauth = requests.get(\n            BASE_URL + ADMIN_USERS_ENDPOINT,\n            timeout=TIMEOUT\n        )\n    except requests.RequestException as e:\n        assert False, f\"Request for unauthorized access failed: {e}\"\n    else:\n        assert response_unauth.status_code in (401, 403), f\"Expected 401 or 403 for unauthorized access, got {response_unauth.status_code}\"\n\ntest_admin_users_list_and_access_control()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-17T18:00:16.902Z",
    "modified": "2025-11-17T18:02:56.063Z"
  }
]
